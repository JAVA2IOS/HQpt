GCD + NSOperationQueue

GCD
会自动管理线程的生命周期（创建线程、调度任务以及销毁线程），不需要编写任务线程管理的代码，只需要实现执行的任务
核心概念：任务 + 队列
函数中的block中的代码即为需要执行的任务
队列的执行方法：
	同步执行dispatch_sync(queue,^{})
		不具备开启新线程的能力，会阻塞当前的线程
	异步执行dispatch_async(queue,^{})
		不会阻塞当前线程，可以开启新的线程
队列，执行方法当中的queue参数即为队列，表示当前的任务执行添加到指定的队列当中执行。任务执行为先进先出(FIFO)原则
	一般有三种：
		dispatch_get_main()主线程
		dispatch_get_gloable_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0(不设置0，返回的有可能为Null))全局并发队列(三种优先级)
		dispatch_queue_t	自定义手动创建队列(可以创建为串行serial或者并发concurrent队列(并发性效果只在异步执行(async)时有效))

同/异步 + 串行/并发队列  组合会形成不同的执行效果
同 + 串  ： 顺序执行
同 + 并 ： 顺序执行 (没有开启新的线程，并发执行的效果只在异步执行的时候有效)
异 + 串 ： 顺序执行 (开启了新的线程)
异 + 并发 ： 并发执行 （开启了新的线程，并发执行）

额外的  主队列(dispatch_get_main())，同步时会造成死锁

延时执行
	dispatch_after(dispatch_time(DISPATCH_TIME_NOW,(int64_t)(延迟秒数 * NSEC_PER_SEC)), queue, ^{});

栅栏方法 dispatch_barrier_async (需要之前的并发任务执行完后才执行当前任务，为异步执行，前提，当前队列为并发队列，前面的任务为异步执行的并发任务)

单例
	dispatch_once
	创建单例
		static 确保常量不再重新初始化
		static Class *class = nil;
		static dispatch_once_t onceToken;
		dispatch_once(&onceToken, ^{
			class = [[Class alloc] init];
		});

		return class;

快速迭代方法（循环）dispatch_apply(需要迭代的次数, queue, ^(size_t index 迭代的第几次){});

*** 队列组 dispatch_group
	dispatch_group_enter(group) 和dispatch_group_leave(group)成对出现，可以防止共用的数据被错误改写(多个任务更新同一个数据时有可能出现该情况)
	创建队列组  dispatch_group_ t group = dispatch_group_create();
	 dispatch_group_async(group, queue, ^{});

	 等待前面的任务全部完成，执行以下任务，一般回到主线程通知
	 dispatch_group_notify(group, queue, ^{})
	 额外的  等待队列  dispatch_group_wait(group, 时间)表示等待前面的任务执行完后执行当前队列，或者等待时间结束后，执行当前队列，但是为阻塞当前线程


** 线程同步问题  dispatch_semaphore  信号量  使用计数功能，当计数功能为0时，不执行当前数据，当计数大于0时，可以通过
		dispatch_semaphore_create: 创建一个信号量并初始化线程信号量
		dispatch_semaphore_signal:发送新号，让信号量 +1
		dispatch_semaphore_wait : 让信号量 - 1 信号量为0时,阻塞当前线程，否则执行方法
作用 ： 将多个异步执行的任务转换为同步执行， 保证线程的安全，共用的数据在多个队列中时可以为共用的数据加同步锁，防止数据错乱

