ios内存管理
	原理
	objc使用引用计数(Reference counting)来管理内存，对象使用创建时，引用计数+1，使用结束时引用计数-1，只有当引用计数变为0时，当前对象内存会被释放回收。
	原因
	 objc的内存管理中，普通的常量变量一般放在栈区内，这是一段连续的内存空间，根据先进先出(FIFO)原则，由系统内部自行管理该段内存空间
	 而Objc的一般引用型对象(NS开头)时，是分配在堆区的内存，是无序分配的，所以容易导致，对象与对象之间产生一段不可控的内存间隙，如果不及时回收，会造成内存的浪费，当引用类型对象
	 分配过多时，有可能造成内存的溢出，当前的内存管理方式(mrc,arc)都是主要针对堆区的内存管理，栈区的内存管理是由系统内部管理的。

	 自动释放池，主要解决连续循环代码的内存峰值问题
	 //自动释放池是延时释放的，系统会将需要释放内存的对象添加到最近的释放池当中，只有到当前的释放池推出当前的栈时，才会将释放池里的内存进行释放
	 @autoreleasepool {
	 	// arc模式下
	 }

	 NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
	 	// 代码块
	 [pool drain];
	 属性
	 原子性： nonatomic, atomic 多线程时，使用atomic可以保持数据的安全性，但是会降低效率，不使用多线程时，nonatomic会提高效率
	 读取权限： readwrite, readonly
	 内存管理
	 weak  修饰对象，弱引用，解决循环引用问题，weak保存的是内存地址，释放时，会将当前地址指向nil
	 assign 通常为常量赋值操作，不进行引用计数
	 retain 引用计数加1，可以使用strong代替(arc)  先释放(release)旧值，再retain新值
	 copy 拷贝一份当前数据到新的地址中

	 *block需要使用copy修饰，arc中如果不添加copy修饰符，系统自动添加copy修饰符使用,作用是，将block从栈区添加到堆区内管理